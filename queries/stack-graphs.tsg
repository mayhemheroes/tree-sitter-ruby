global FILE_PATH
global ROOT_NODE

attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute scoped_node_definition = node => type = "pop_scoped_symbol", node_symbol = node, is_definition
attribute node_reference = node         => type = "push_symbol", node_symbol = node, is_reference
attribute scoped_node_reference = node  => type = "push_scoped_symbol", node_symbol = node, is_reference
attribute pop_node = node               => type = "pop_symbol", node_symbol = node
attribute pop_scoped_node = node        => type = "pop_scoped_symbol", node_symbol = node
attribute push_node = node              => type = "push_symbol", node_symbol = node
attribute push_scoped_node = node       => type = "push_scoped_symbol", node_symbol = node
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol
attribute pop_scoped_symbol = symbol    => type = "pop_scoped_symbol", symbol = symbol
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute push_scoped_symbol = symbol   => type = "push_scoped_symbol", symbol = symbol

attribute node_symbol = node            => symbol = (source-text node), source_node = node

(program)@prog {
    node @prog.NULL_VALUE
    node @prog.before_scope
    node @prog.after_scope
    edge @prog.before_scope -> ROOT_NODE
}

(program
  .
  (_)@first_stmt)@prog {
    edge @first_stmt.before_scope -> @prog.before_scope
}

(program
  (_)@left_stmt
  .
  (_)@right_stmt) {
  edge @right_stmt.before_scope -> @left_stmt.after_scope
}

(program
  (_)@last_stmt
  .)@prog {
  edge @prog.after_scope -> @last_stmt.after_scope
}

; This allows all nodes to propagate a NULL_VALUE variable down through the CST.
(_
  (_)@child)@parent {
  let @child.NULL_VALUE = @parent.NULL_VALUE
}

(comment)@comment {
  node @comment.before_scope
  node @comment.after_scope
  node @comment.value
  edge @comment.after_scope -> @comment.before_scope
}

(assignment
  left:(identifier)@name
  right:(_)@right)@assignment {

  node @assignment.before_scope
  node @assignment.after_scope
  node @assignment.value
  node @name.pop
  attr (@name.pop) node_definition = @name
  edge @right.before_scope -> @assignment.before_scope
  edge @assignment.after_scope -> @right.after_scope
  edge @assignment.after_scope -> @name.pop
  edge @name.pop -> @right.value
  edge @assignment.value -> @right.value
}

(_arg/identifier)@identifier {
  node @identifier.before_scope
  node @identifier.after_scope
  node @identifier.value
  attr (@identifier.value) node_reference = @identifier
  edge @identifier.after_scope -> @identifier.before_scope
  edge @identifier.value -> @identifier.before_scope
}

(parenthesized_statements)@ps {
  node @ps.before_scope
  node @ps.after_scope
  node @ps.value
}

(parenthesized_statements
  .
  (_)@first_stmt)@ps {
    edge @first_stmt.before_scope -> @ps.before_scope
}

(parenthesized_statements
  (_)@left_stmt
  .
  (_)@right_stmt) {
  edge @right_stmt.before_scope -> @left_stmt.after_scope
}

(parenthesized_statements
  (_)@last_stmt
  .)@ps {
  edge @ps.after_scope -> @last_stmt.after_scope
  edge @ps.value -> @last_stmt.value
}

(integer)@integer {
  node @integer.before_scope
  node @integer.after_scope
  node @integer.value
  edge @integer.after_scope -> @integer.before_scope
  ;edge @integer.value -> @integer::INTEGER_CLASS (?ask about builtin variable syntax)
}

(if
  condition:(_)@cond)@if {
  node @if.before_scope
  node @if.after_scope
  node @if.value
  edge @cond.before_scope -> @if.before_scope
}

(if
  condition:(_)@cond
  !consequence
  !alternative)@if {
  edge @if.after_scope -> @cond.after_scope
  edge @if.value -> @if.NULL_VALUE
}

(if
  condition:(_)@cond
  consequence:(_)@consequence)@if {
  node @consequence.before_scope
  node @consequence.after_scope
  edge @consequence.before_scope -> @cond.after_scope
  edge @if.after_scope -> @consequence.after_scope
  edge @if.value -> @consequence.value
}

(if
  condition:(_)@cond
  alternative:(_)@alternative)@if {
  node @alternative.before_scope
  node @alternative.after_scope
  edge @alternative.before_scope -> @cond.after_scope
  edge @if.after_scope -> @alternative.after_scope
  edge @if.value -> @alternative.value
}

(then)@then {
  node @then.value
}

(then
  .
  (_)@first_stmt)@then {
    edge @first_stmt.before_scope -> @then.before_scope
}

(then
  (_)@left_stmt
  .
  (_)@right_stmt) {
  edge @right_stmt.before_scope -> @left_stmt.after_scope
}

(then
  (_)@left_stmt
  .
  (comment)@right_stmt) {
  edge @right_stmt.value -> @left_stmt.value
}

(then
  (_)@last_stmt
  .)@then {
  edge @then.after_scope -> @last_stmt.after_scope
  edge @then.value -> @last_stmt.value
}

; TODO:  this is to ensure empty then statements do not break the graph.
; Fix this when tree-sitter is updated to support queries for empty children.
(then)@then {
  edge @then.after_scope -> @then.before_scope
  edge @then.value -> @then.NULL_VALUE
}

(else)@else {
  node @else.value
}

(else
  .
  (_)@first_stmt)@else {
    edge @first_stmt.before_scope -> @else.before_scope
}

(else
  (_)@left_stmt
  .
  (_)@right_stmt) {
  edge @right_stmt.before_scope -> @left_stmt.after_scope
}

(else
  (_)@left_stmt
  .
  (comment)@right_stmt) {
  edge @right_stmt.value -> @left_stmt.value
}

(else
  (_)@last_stmt
  .)@else {
  edge @else.after_scope -> @last_stmt.after_scope
  edge @else.value -> @last_stmt.value
}

; TODO:  this is to ensure empty then statements do not break the graph.
; Fix this when tree-sitter is updated to support queries for empty children.
(else)@else {
  edge @else.after_scope -> @else.before_scope
  edge @else.value -> @else.NULL_VALUE
}
